#运行程序后输入文件夹名和语言
import os
import time
from docx import Document
import requests
from tqdm import tqdm

# 配置DeepSeek API参数
DEEPSEEK_API_KEY = "sk-×××××××××××××××××××××××××××××××"
API_URL = "https://api.deepseek.com/v1/chat/completions"

VALID_LANGUAGES = ["德文", "法文", "英文", "日文", "丹麦文","意大利文"]

class BatchTranslator:
    def __init__(self):
        self.total_files = 0
        self.processed_files = 0
        self.failed_files = []

    def translate_text(self, text, source_lang):
        """翻译单个段落"""
        headers = {
            "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
            "Content-Type": "application/json"
        }
        
        prompt = (
            f"请将以下{source_lang}文本专业地翻译成中文：\n{text}\n"
            "要求：\n1.保持格式 2.术语准确 3.译文不添加注释 4.语言通顺连贯"
        )
        
        payload = {
            "model": "deepseek-chat",
            "messages": [
                {"role": "system", "content": "你是一名专业翻译人员"},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.1
        }
        
        timeout_config = (3.05, 60)  # 连接超时3秒，读取超时60秒
        retry_delay = [5, 15, 30]    # 重试间隔(秒)
    
        for attempt in range(3):
            try:
                response = requests.post(
                    API_URL,
                    headers=headers,
                    json=payload,
                    timeout=timeout_config
                )
                return response.json()['choices'][0]['message']['content']
            except requests.exceptions.Timeout:
                if attempt == 2:
                    raise
                print(f"超时重试 ({attempt+1}/3)...")
                time.sleep(retry_delay[attempt])
            except Exception as e:
                raise

    def process_single_file(self, input_path, source_lang):
        """处理单个Word文件"""
        try:
            doc = Document(input_path)
            new_doc = Document()
            new_doc.styles['Normal'].font.name = '宋体'

            # 翻译进度条
            with tqdm(total=len(doc.paragraphs), desc=os.path.basename(input_path)) as pbar:
                for para in doc.paragraphs:
                    if para.text.strip():
                        translated = self.translate_text(para.text, source_lang)
                        new_doc.add_paragraph(translated)
                    else:
                        new_doc.add_paragraph()
                    pbar.update(1)

            # 生成输出路径
            base_name = os.path.splitext(input_path)[0]
            output_path = f"{base_name}_translated.docx"
            
            # 避免覆盖已存在文件
            counter = 1
            while os.path.exists(output_path):
                output_path = f"{base_name}_translated({counter}).docx"
                counter += 1
                
            new_doc.save(output_path)
            return True
        except Exception as e:
            self.failed_files.append((input_path, str(e)))
            return False

    def process_folder(self, folder_path, source_lang):
        """处理整个文件夹"""
        if not os.path.isdir(folder_path):
            raise NotADirectoryError("路径不是有效文件夹")

        # 获取所有需要处理的Word文件
        valid_files = []
        for file in os.scandir(folder_path):
            if file.is_file() and file.name.lower().endswith('.docx'):
                if "_translated" not in file.name:
                    valid_files.append(file.path)

        self.total_files = len(valid_files)
        if self.total_files == 0:
            print("文件夹中没有可处理的Word文件")
            return

        print(f"发现 {self.total_files} 个需要处理的文件")
        
        # 处理每个文件
        for file_path in valid_files:
            self.processed_files += 1
            print(f"\n正在处理文件 ({self.processed_files}/{self.total_files}):")
            print(os.path.basename(file_path))
            
            start_time = time.time()
            success = self.process_single_file(file_path, source_lang)
            elapsed = time.time() - start_time
            
            if success:
                print(f"√ 完成 用时: {elapsed:.1f}秒")
            else:
                print(f"× 失败 用时: {elapsed:.1f}秒")

    def generate_report(self):
        """生成处理报告"""
        print("\n处理结果汇总：")
        print(f"成功处理: {self.processed_files - len(self.failed_files)}/{self.total_files}")
        if self.failed_files:
            print("\n失败文件列表：")
            for path, error in self.failed_files:
                print(f"- {os.path.basename(path)}: {error}")

def main():
    translator = BatchTranslator()
    
    try:
        # 获取用户输入
        folder_path = input("请输入文件夹路径：").strip()
        while not os.path.isdir(folder_path):
            print("路径无效，请重新输入！")
            folder_path = input("请输入文件夹路径：").strip()

        # 语言选择
        print("\n可选语言：" + "/".join(VALID_LANGUAGES))
        source_lang = input("请选择原文语言：").strip()
        while source_lang not in VALID_LANGUAGES:
            print("无效语言选择！")
            source_lang = input("请重新选择：").strip()

        # 开始处理
        start_time = time.time()
        translator.process_folder(folder_path, source_lang)
        print(f"\n总用时：{time.time() - start_time:.1f}秒")

        # 生成报告
        translator.generate_report()

    except Exception as e:
        print(f"\n发生严重错误：{str(e)}")

if __name__ == "__main__":
    main()
